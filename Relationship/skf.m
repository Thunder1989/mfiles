function S = skf(y,A,H,Q,R,x_0,Z,pi)

% SKF  Switching Kalman filter
%
%   S = skf_adf(y,A,H,Q,R,x_0,Z,pi)
%
%   Given descriptions of a number of dynamical systems
%   represented as state spaces, and some data, calculate the
%   probability distribution of the switch states (the probability
%   that each data point was generated by any one of the systems).
%   
%   Inference is filtering only - the probability distribution
%   of a switch setting at time t depends only on the data from
%   times 1:t.
%
%   ARGUMENTS:
%    y(t,:)      observation at time t, zero mean
%    A(:,:,j)    transition matrix for state j
%    H(:,:,j)    emission matrix for state j
%    Q(:,:,j)    state j transition noise
%    R(:,:,j)    state j measurement noise
%    x_0(:)      initial estimate of hidden state
%    Z(i,j)      transition probability of discrete 
%                state i -> j
%    pi(1,i)     prior probability of discrete state i
%   OUTPUT:
%    S(t,i)      output, P(S_t=i|y)
%
%   Approximate inference using Gaussian mixtures.

% Author: John Quinn 2005

% Murphy (1998), Switching Kalman Filters, esp. section 2.3 
% Welch and Bishop (2004), An Introduction to the Kalman Filter

[T d_obs] = size(y);
d_state = size(A,1); 
M = size(Z,1);
P_0 = eye(d_state);
x = zeros(d_state,M,T+1);
x_ij = zeros(d_state,M,M);
P_ij = zeros(d_state,d_state,M,M);
S = zeros(T+1,M);
S_ij = zeros(M,1);
I = eye(d_state);

x(:,:,1) = repmat(x_0,1,M);
for i=1:M
  P(:,:,i) = P_0;
end
S(1,:) = pi;

y = [zeros(1,d_obs);y]; 

for t=2:T+1

  S_norm = 0;
  S_marginal = zeros(M,M);

  for j=1:M
    A_j = A(:,:,j);
    H_j = H(:,:,j);
    Q_j = Q(:,:,j);
    R_j = R(:,:,j);

    for i=1:M
      % kalman update for each state
      x_minus = A_j * x(:,i,t-1);
      P_minus = A_j * P(:,:,i) * A_j' + Q_j;
      K = (P_minus * H_j') * inv(H_j*P_minus*H_j' + R_j);
      P_ij(:,:,i,j) = (I - K*H_j)*P_minus;
      x_ij(:,i,j) = x_minus + K*(y(t,:)' - H_j*x_minus);

      % likelihood of data given S_t=j,S_t-1=i
      a = y(t,:) - (H_j*x_minus)';
      covar = H_j*P_minus*H_j' + R_j;
      b = sum(((a*inv(covar)).*a), 2);
      L = (det(covar))^-.5;
      L = L * exp(-.5*b);

      S_marginal(i,j) = L * Z(i,j) * S(t-1,i);
      S_norm = S_norm + S_marginal(i,j);     
    end
  end

  % posterior for state j at time t
  S_marginal = S_marginal/S_norm;
  for j=1:M
    S(t,j) = sum(S_marginal(:,j));
  end

  % weights of state components
  for j=1:M
    for i=1:M
      W(i,j) = S_marginal(i,j)/S(t,j);
    end
  end

  % approximate new continuous state
  for j=1:M
    x(:,j,t) = x_ij(:,:,j) * W(:,j);
    P(:,:,j) = zeros(d_state);
    for i=1:M
      m = x_ij(:,i,j) - x(:,j,t);
      P(:,:,j) = P(:,:,j) + W(i,j)*(P_ij(:,:,i,j) + m*m');
    end
  end
end

S = S(2:T+1,:);
